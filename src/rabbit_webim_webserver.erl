-module(rabbit_webim_webserver).

-export([start_link/0, stop/0, leave/2]).

%% export dispatch here, otherwise it will not be generated by compiler.
-export([dispatch/3]).

-include("../include/rabbit_webim_db.hrl").
-include("../include/rabbit_webim.hrl").
-include_lib("amqp_client/include/amqp_client.hrl").

start_link() ->
    %%Options = application:get_all_env(rabbitmq_webim),
    Options = [
            {ip, "0.0.0.0"},
            {port, 8000},
            {acceptor_pool_size, 200}
            ],
    {ok, Conn} = amqp_connection:start(#amqp_params_direct{}),
    Options1 = [{loop, {?MODULE, dispatch, [docroot(), Conn]}} | Options],
    Options2 = [{name, webim_webserver} | Options1],
    mochiweb_http:start(Options2).

stop() ->
    mochiweb_http:stop(webim_webserver).


dispatch(Req, Docroot, Conn) ->
    M = Req:get(method),
    P = Req:get(path),
    log("receive http request: ~p ~p~n", [M, P]),
    try
        case {M,P} of
            {'GET',  "/static/" ++ RelPath}  -> static(Req, RelPath, Docroot);
            {'GET',  "/favicon.ico"}         -> favicon(Req, Docroot);
            {'GET',  "/"}                    -> mainpage(Req, Docroot);
            {'GET',  "/login"}               -> loginpage(Req, Docroot);
            {'POST', "/login"}               -> login(Req, Conn);
            {'POST', "/signup"}              -> signup(Req, Conn);
            {'GET',  "/logout"}              -> logout(Req);
            {'POST', "/msg"}                 -> msg(Req);
            {'GET',  "/whoami"}              -> whoami(Req);
            {'GET',  "/friendlist"}          -> friendlist(Req);
            {'GET',  "/hello"}               -> hello(Req);
            {'POST', "/clear"}               -> clear(Req);
            {'GET',  "/emotions"}            -> emotions(Req, Docroot);
            {'GET',  "/userlist"}            -> unimplemented(M, P, Req);
            {'PUT',  "/friendrequest"}       -> unimplemented(M, P, Req);
            {'PUT',  "/friendrefuse"}        -> unimplemented(M, P, Req);
            {'PUT',  "/friendconfirm"}       -> unimplemented(M, P, Req);
            {'PUT',  "/dropblack"}           -> unimplemented(M, P, Req);
            {'PUT',  "/filemsg"}             -> unimplemented(M, P, Req);
            {_, _}                           -> unsupported(M, P, Req)
        end
    catch
        _:E ->  logout0(Req, "Internal server error, please relogin"),
                json(Req, [{result, false}, {message, 'internal server error'}]),
                io:format("~p ~p: internal server error: ~p~n~p~n", [M, P, E, erlang:get_stacktrace()])
    end.

unimplemented(Method, Path, Req) ->
    io:format("Unimplemented method: ~p, path: ~p~n", [Method, Path]),
    Req:respond({200, [{"Content-Type", "text/plain"}], <<"unimplemented">>}).

unsupported(Method, Path, Req) ->
    io:format("Unsupported method: ~p, path: ~p~n", [Method, Path]),
    Req:respond({200, [{"Content-Type", "text/plain"}], <<"unsupported">>}).

favicon(Req, _Docroot) ->
    Req:respond({200, [], <<"favicon">>}).

static(Req, RelPath, Docroot) ->
    Req:serve_file(RelPath, Docroot).

emotions(Req, Docroot) ->
    {ok, F} = file:open(filename:join(Docroot, "img/emotion/emotion_en.ini"), read),
    Lines = lines([], F),
    file:close(F),
    Emotions = [[{file, File}, {hint, Hint}] || {File, Hint} <- Lines],
    json(Req, [{result, true}, {emotionlist, Emotions}]).

lines(Ls, F) ->
    case file:read_line(F) of
        {ok, L} ->
            [File, Hint] = string:tokens(L, "=\n"),
            lines([{list_to_binary(File), list_to_binary(Hint)} | Ls], F);
        eof -> Ls
    end.

mainpage(Req, Docroot) ->
    case session(Req) of
        undefined -> redirect(Req, "/login");
        _Session -> Req:serve_file("index.html", Docroot)
    end.

loginpage(Req, Docroot) ->
    case session(Req) of
        undefined -> Req:serve_file("login.html", Docroot);
        _Session -> redirect(Req, "/")
    end.

login(Req, Conn) ->
    Post = Req:parse_post(),
    UserId = proplists:get_value("userid", Post),
    Password = proplists:get_value("password", Post),
    case {UserId, Password} of
        {undefined, _} -> redirect(Req, "/login");
        {_, undefined} -> redirect(Req, "/login");
        _ -> case rabbit_webim_db:validate(UserId, Password) of
                true -> leave(UserId, "You have logged in at other place, quit forcefully."),
                        login0(Req, UserId, Conn);
                false -> redirect(Req, "/login")
             end
            
    end.

login0(Req, UserId, Conn) ->
    Guid = rabbit_guid:gen(),
    SessionId = rabbit_guid:string(Guid, "wim"),
    {ok, Channel} = amqp_connection:open_channel(Conn),
    BUId = list_to_binary("q_" ++ UserId),
    #'queue.declare_ok'{} = amqp_channel:call(Channel, #'queue.declare'{queue= BUId, durable=true}),
    {ok, Pid} = rabbit_webim_mqclient_sup:start_mqclient(SessionId, UserId, Channel),
    rabbit_webim_session:add_session(SessionId, UserId, Pid, Channel),
    redirect(Req, "/", [setsid(SessionId)]).

signup(Req, Conn) ->
    Post = Req:parse_post(),
    UserName = proplists:get_value("username", Post),
    Password = proplists:get_value("password", Post),
    Email = proplists:get_value("email", Post),
    #wim_user{id=UserId, name=UserName, email=Email} = rabbit_webim_db:add_user(UserName, Password, Email),
    login0(Req, UserId, Conn).

logout(Req) ->
    logout0(Req, normal),
    redirect(Req, "/login").

logout0(Req, Msg) ->
    case session(Req) of
        undefined -> ok;
        {_, UserId, _, _} -> leave(UserId, Msg)
    end.

leave(UserId, Msg) ->
    case rabbit_webim_session:del_session_of_user(UserId) of
        undefined -> ok;
        {_, UserId, MQClientPid, MQChannel}   ->
            rabbit_webim_mqclient:stop(MQClientPid, Msg),
            amqp_channel:close(MQChannel)
    end.

msg(Req) ->
    case session(Req) of
        undefined -> json(Req, [{result, false}, {message, 'not log in'}]);
        {_SessionId, UserId, _MQClientPid, MQChannel} ->
            Post = Req:parse_post(),
            UserId = proplists:get_value("fromid", Post),
            ToUid = proplists:get_value("toid", Post),
            Content = proplists:get_value("content", Post),
            Time = rabbit_webim_misc:mktime(),
            BinContent = list_to_binary(Content),
            Publish = #'basic.publish'{exchange= <<>>, routing_key= list_to_binary("q_"++UserId)},
            Props = #'P_basic'{delivery_mode=2, headers=setheader(UserId, ToUid, Time)},
            Msg = #amqp_msg{props=Props, payload = BinContent},
            amqp_channel:cast(MQChannel, Publish, Msg),
            Publish1 = #'basic.publish'{exchange= <<>>, routing_key= list_to_binary("q_"++ToUid)},
            amqp_channel:cast(MQChannel, Publish1, Msg),
            json(Req, [{result, true}])
    end.


whoami(Req) ->
    case session(Req) of
        undefined -> json(Req, [{result, false}, {message, 'not login'}]);
        {_SessionId, UserId, _MQClientPid, _MQChannel} ->
            case rabbit_webim_db:get_user(UserId) of
                [] -> json(Req, [{result, false}, {message, 'not exist'}]);
                [#wim_user{id=UserId, name=Name, email=Email}] ->
                    BUserId = list_to_binary(UserId),
                    BName = list_to_binary(Name),
                    BEmail = list_to_binary(Email),
                    json(Req, [{result, true}, {user, [{id, BUserId}, {name, BName}, {email, BEmail}]}]);
                _ -> json(Req, [{result, false}, {message, 'internal error'}])
            end
    end.

friendlist(Req) ->
    case session(Req) of
        undefined -> json(Req, [{result, false}, {message, 'not login'}]);
        {_SessionId, UserId, _MQClientPid, _MQChannel} ->
            Fs = rabbit_webim_misc:friends_status(UserId),
            log("friendlist: ~p~n", [Fs]),

            Result = [[{id, list_to_binary(Id)}, {name, list_to_binary(Name)}, {email, list_to_binary(Email)}, {status, Status}] || {#wim_user{id=Id, name=Name, email=Email}, Status} <- Fs],
            json(Req, [{result, true}, {friends, Result}])
    end.

hello(Req) ->
    case session(Req) of
        undefined -> json(Req, [{result, false}, {message, 'not login'}]);
        {SessionId, UserId, MQClientPid, _MQChannel} ->
            ok = rabbit_webim_mqclient:subscribe(MQClientPid, SessionId, UserId),
            receive
                {deliver_msg, Msgs} ->
                    Ms = [[{fromid, FromUid}, {toid, ToUid}, {time, Time}, {content, Content}] || #msg{from=FromUid, to=ToUid, time=Time, content=Content} <- Msgs],
                    json(Req, [{result, true}, {count, length(Ms)}, {msgs, Ms}]);
                {friend_status_change, Fs} ->
                    FS = [[{fid, list_to_binary(Fid)}, {status, Status}] || {Fid, Status} <- Fs],
                    json(Req, [{result, true}, {friend_status, FS}])
            after 10000 ->
                json(Req, [{result, true}, {count, 0}])
            end,
            rabbit_webim_mqclient:unsubscribe(MQClientPid)
    end.

clear(Req) ->
    case session(Req) of
        undefined -> json(Req, [{result, false}, {message, 'not login'}]);
        {_SessionId, _UserId, MQClientPid, _MQChannel} ->
            ok = rabbit_webim_mqclient:ack(MQClientPid),
            json(Req, [{result, true}])
    end.

%% ------- helper functions ----------
sid(Req) ->
    Req:get_cookie_value("webim_sid").
setsid(SID) ->
    mochiweb_cookies:cookie("webim_sid", SID).
    
session(Req) ->
    case sid(Req) of
        undefined -> undefined;
        Sid when is_list(Sid) ->
            rabbit_webim_session:get_session(Sid);
        _ -> undefined
    end.

redirect(Req, Path) ->
    Req:respond({301, [{"Location", Path}], ""}).

redirect(Req, Path, ExtraHeaders) ->
    Req:respond({301, [{"Location", Path}|ExtraHeaders], ""}).

json(Req, Data) ->
    log("json: ~p~n", [Data]),
    Result = mochijson2:encode(Data),
    %%log("json: ~p~n", [Result]),
    Req:respond({200, [], Result}).

setheader(FromId, ToId, Time) ->
    H1 = rabbit_misc:set_table_value([], <<"wim-from-user-id">>, longstr, list_to_binary(FromId)),
    H2 = rabbit_misc:set_table_value(H1, <<"wim-to-user-id">>, longstr, list_to_binary(ToId)),
    rabbit_misc:set_table_value(H2, <<"wim-timestamp">>, longstr, list_to_binary(Time)).

docroot() ->
    {file, File} = code:is_loaded(?MODULE),
    filename:dirname(filename:dirname(File)) ++ "/priv/www/".

log(Fmt) ->
    io:format(Fmt).
log(Fmt, Vars) ->
    io:format(Fmt, Vars).
